---
id: dataAndStorage
title: ذخیره‌سازی داده‌ها
sidebar_label: ذخیره‌سازی داده‌ها
---

## بیت

خیلی در مورد زبان کامپیوتر که ۰ و ‍۱ است صحبت شده است. گفتیم گیت‌های منطقی ورودی‌های ۰ یا ۱ دارند. ۰ و ۱ بیانگر وصل بودن یا نبودن سیگنال است. واحد نگهداری هر ۰ یا ۱، یک بیت (Bit) است.

## بایت

یک گروه ۸ تایی از بیت‌ها یک بایت (byte) را تشکیل می‌دهند. گفتیم هر بیت یک رقم در مبنای ۲ است، یعنی مقدار ۰ یا ۱ را نگه می‌دارد. به همین صورت می‌توان گفت با ۴ بیت، می‌توان یک رقم در مبنای ۱۶ را نگهداری کرد. پس یک بایت را می‌توان با دو رقم در مبنای ۱۶ نشان داد.

| Decimal | Hexadecimal | Binary |
| ------- | ----------- | ------ |
| 0       | 0           | 0      |
| 1       | 1           | 1      |
| 2       | 2           | 10     |
| 9       | 9           | 1001   |
| 10      | A           | 1010   |
| 11      | B           | 1011   |
| 12      | C           | 1100   |
| 13      | D           | 1101   |
| 14      | E           | 1110   |
| 15      | F           | 1111   |
| 16      | 10          | 10000  |

بایت کوچک‌ترین واحد قابل آدرسی‌دهی در سیستم است.

## ASCII

گفتیم داده‌ها به صورت ۰ یا ۱ ذخیره می‌شوند و هر بایت ۸ بیت است. کاراکترها چگونه ذخیره می‌شوند؟
یک سیستم استاندارد برای ذخیره‌سازی کاراکتر‌ها وجود دارد به نام ASCII. در این سیستم، هر عدد بین ۰ تا ۱۲۷ به یک کاراکتر تبدیل شده است. به عنوان مثال، برای نشان داده حرف A، عدد ۶۵ را ذخیره می‌کنیم. سپس زمان خواندن داده‌ها از حافظه، این عدد را به کاراکتر تبدیل می‌کنیم. با توجه به اینکه برای کاراکترها یک عدد بین ۰ تا ۱۲۷ لازم است، پس هر کاراکتر را می‌توان در یک بایت ذخیره کرد.

![ASCII Table](/img/ascii-table.png)

## Unicode

کامپیوترها برای نشان دادن کاراکترهای عادی از ASCII استفاده می‌کنند. اما برای نمایش سایر کاراکتر‌ها، مانند اموجی‌ها، از سیستم Unicode استفاده می‌شود. در این سیستم هر کاراکتر را با ۲ بایت نشان می‌دهند. درنتیجه ۶۵۵۳۶ کاراکتر ممکن در سیستم Unicode قابل نمایش است.

## متغیر چیست؟

متغیر (Variable) برای ذخیره‌سازی جهت آدرسی‌دهی یا تغییر داده‌ها در حافظه استفاده می‌شود. انواع مختلفی از متغییر‌ها وجود دارند. چند مورد پر کاربرد عبارتند از:

- boolean
- character
- integer
- float
- double
- void

هر کدام از این انواع ممکن است در یک زبان وجود داشته باشد یا نداشته باشد یا باشد اما نامی متفاوت داشته باشد.

### boolean

ساده‌ترین نوع متغیر در سیستم boolean است. این متغییر مقدار صفر یا یک را نگهداری می‌کند. برای پیاده‌سازی واضح‌تر در سیستم، مقدار true و false را نیز به عنوان یک و صفر در نظر می‌گیرند. از نظر منطقی برای نگهداری مقدار boolean به یک بیت فضا نیاز است. اما چون کوچک‌ترین واحد آدرس دهی در سیستم یک بایت است، پس فضای لازم برای ذخیره‌سازی boolean در حافظه یک بایت است.

### character

گقتیم کاراکتر‌ها در سیستم به صورت کُد ascii ذخیره می‌شوند. با توجه به اینکه کدهای ascii استاندارد ۱۲۸ حالت مختلف دارند، پس برای نگهداری آن‌ها ۷ بیت کافی است. اما با توجه به اینکه واحد آدرس‌دهی در سیستم بایت است، پس باید از ۸ بیت یا یک باید برای نگهداری هر کاراکتر استفاده کرد.

### integer

گفتیم اعداد به صورت دو دویی در کامپیوتر ذخیره می‌شوند. استاندارد اندازه‌‌ی نگهداری اعداد صحیح (Integer) در کامپیوتر، ۴ بایت یعنی ۳۲ بیت است. با استفاده از ۴ بایت می‌توان ![inlineImage](https://latex.codecogs.com/png.latex?\inline&space;2^{32}) حالت مختلف را ذخیره‌سازی کرد. یعنی از 0 تا 4294967295.
با توجه به اینکه ما اعداد منفی نیز داریم، پس باید آن‌ها را نیز در نظر بگیریم. ساده‌ترین روشی که برای نگهداری اعداد صحیح منفی در کنار اعداد صحیح مثبت به ذهن می‌رسد این است که بیت آخر را برای علامت (sign) نگهداریم. یعنی اگر عدد ۱۰ در مبنای ۲ با ۳۲ بیت 00000000000000000000000000001010 می‌شود، ۱۰- در مبنای ۲ بشود 10000000000000000000000000001010. اما این روش دو مشکل اساسی دارد:

1. عدد 00000000000000000000000000000000 و 10000000000000000000000000000000 هردو نشان‌دهنده‌ی صفر هستند. پس یک حالت از دست می‌رود. همچنین پیچیدگی‌های سطح سخت‌افزار بدون دلیل زیاد می‌شود.

2. جمع یک عدد منفی و یک عدد مثبت یا دو عدد منفی دشوار می‌شود. به عنوان مثال اگر عدد ۱۰ با ۱۰- در مبنای ۲ با ۳۲ بیت جمع شود، حاصل ۲۰- خواهد شد:
   ![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%20%5Cbegin%7Balign*%7D%20%26%5Cquad%20%5C%3B%2000000000000000000000000000001010%5C%5C%20%26+10000000000000000000000000001010%5C%5C%20%5Chline%20%26%3D10000000000000000000000000010100%20%5Cend%7Balign*%7D)
   همچنین اگر ۱۰- را با خودش جمع کنیم، حاصل ۲۰ خواهد شد:
   ![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%20%5Cbegin%7Balign*%7D%20%26%5Cquad%20%5C%3B%2010000000000000000000000000001010%5C%5C%20%26+10000000000000000000000000001010%5C%5C%20%5Chline%20%26%3D00000000000000000000000000010100%20%5Cend%7Balign*%7D)

   درنتیجه فرآیند جمغ و تفریق به شدت دشوار می‌شود و باید سخت‌افزاری پیچیده برای آن در نظر گرفت.

روشی که در عمل برای نگهداری اعداد منفی در کنار اعداد مثبت استفاده می‌شود، به این صورت است که عدد 11111111111111111111111111111111 را به عنوان ۱- درنظر می‌گیرند. اگر یک واحد از این عدد کم کنیم به ۲- می‌رسیم و 11111111111111111111111111111110 را خواهیم داشت. در نتیجه کوچک‌ترین عدد صحیح ۳۲ بیتی برابر خواهد بود با 10000000000000000000000000000000. با این روش دیگر دو حالت برای عدد صفر وجود ندارد. در نتیجه می‌توان اعداد بین ![inlineImage](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%202%5E%7B31%7D-1) و ![inlineImage](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%20-2%5E%7B31%7D) را نمایش داد. مشکل دوم که جمع دو عدد بود نیز در این حالت حل شده است. جمع همان دو عدد ۱۰ و ۱۰- را در نظر بگیرید:
![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%20%5Cbegin%7Balign*%7D%20%26%5Cquad%20%5C%3B%2000000000000000000000000000001010%5C%5C%20%26+11111111111111111111111111110110%5C%5C%20%5Chline%20%26%3D00000000000000000000000000000000%20%5Cend%7Balign*%7D)

حاصل این جمع در واقع یک رقم ۱ و ۳۲ رقم ۰ می‌شود. اما چون ۳۲ رقم بیشتر نداریم، رقم ۱ بیرون از حافظه می‌افتد که به این اتفاق سرریز (Overflow) گفته می‌شود.

### float

نحوه‌ی ذحیره شدن اعداد اعشاری در سیستم پیچیده‌تر است. اعداد اعشاری را می‌توان به شیوه‌های مختلفی نمایش داد:

![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%203.1415%5C%5C%200.0314%20%5Ctimes%2010%5E2%5C%5C%20314.15%20%5Ctimes%2010%5E%7B-2%7D)

هر سه این شیوه‌ها صحیح است، اما باید یک نمونه را استاندارد در نظر گرفت و به همان صورت تمام اعداد را نوشت. نماد علمی یک استاندارد است. به این صورت که یک رقم قبل از ممیز قرار می‌گیرد و این رقم نباید صفر باشد. درنتیجه در شکل بالا اولین مورد استاندارد است. در مبنای ۲ به این صورت نمایش داده می‌شود:

![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%201.1001001000011100101011%20%5Ctimes%202%5E1)

سوالی که مطرح است این است که به چه صورت این مقدار را در حافظه ذخیره کنیم. فرم کلی اعداد اعشاری در مبنای ۲ به این صورت است:

![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%20%28-/+%29%201.%5Bmantissa%5D%20%5Ctimes%202%5E%7B%5Bexponent%5D%7D)

با توجه به اینکه در نماد علمی همواره رقم پشت ممیز باید صفر نباشد، در مبنای ۲ این عدد همواره یک خواهد بود. پس می‌توان آن قسمت را در نظر نگرفت.
در استاندارد IEEE 754 اعداد اعشاری (Float / Signle Precision) را با ۳۲ بیت نمایش می‌دهند. از این ۳۲ بیت، یک بیت برای علامت مثبت یا منفی، ۸ بیت برای توان و ۲۳ بیت برای قسمت اعشاری در نظر گرفته می‌شود:

![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%20%5Bsign%2831%29%5D%20%5Bexponent%2830..23%29%5D%5Bmantissa%2822..0%29%5D%5C%5C%20%5C%5C%20exponent%20%3D%20%28b_%7B30%7D...b_%7B23%7D%29_%7B2%7D%5C%5C%20%5C%5C%20value%20%3D%20%28-1%29%5E%7Bb_%7B31%7D%7D%20%5Ctimes%202%5E%7Bexponent-127%7D%20%5Ctimes%20%281.b_%7B22%7D...b_%7B0%7D%29_%7B2%7D)

با توجه به اینکه گفتیم رقم اول که ذخیره نمی‌شود همواره ۱ است، پس برای نمایش عدد ۰ مشکل خواهیم داشت.
دو حالت خاص برای این شیوه‌ی ذخیره سازی وجود دارد:

1. اگر توان صفر باشد (بیت‌های ۲۳ تا ۳۰ همگی صفر باشند) نشان‌دهنده‌ی عدد صفر است.
2. اگر بیت‌های توان (بیت‌های ۲۳ تا ۳۰) همگی یک باشند، نشان‌دهنده‌ی بی‌نهایت است.

باید توجه داشت که عدد ذخیره شده به عنوان عدد اعشاری دقیق نیست. به عنوان مثال عدد ۰.۱ در مبنای ۲ را نمی‌توان دقیق نشان داد، زیرا در مبنای ۲ به دور گردش می‌افتد. درنتیجه دقت اعداد اعشاری در کامپیوتر محدود است. به عنوان مثال، اگر در یک سیستم بانکی، موجودی حساب‌ها به صورت float ذخیره شود، احتمالا در انتهای سال بانک با کسری زیادی مواجه خواهد شد، زیرا قسمتی از اعداد هیچ‌گاه ذخیره نشده‌اند.

### double

اعداد اعشاری با دقت دو برابر (Double / Double Precision) مشابه float هستند. با این تفاوت که در استاندارد IEEE 754 فضای ذخیره‌سازی آن ۶۴ بیت در نظر گرفته شده‌است. از این ۶۴ بیت، یک بیت برای علامت، ۱۱ بیت برای توان و ۵۲ بیت برای قسمت اعشاری در نظر گرفته می‌شود:

![image](https://latex.codecogs.com/png.latex?%5Cinline%20%5Csmall%20%5Bsign%2863%29%5D%20%5Bexponent%2862..52%29%5D%5Bmantissa%2851..0%29%5D%5C%5C%20%5C%5C%20exponent%20%3D%20%28b_%7B62%7D...b_%7B52%7D%29_%7B2%7D%5C%5C%20%5C%5C%20value%20%3D%20%28-1%29%5E%7Bb_%7B63%7D%7D%20%5Ctimes%202%5E%7Bexponent-1023%7D%20%5Ctimes%20%281.b_%7B51%7D...b_%7B0%7D%29_%7B2%7D)

### void

نوع void بیانگر هیچ است. یعنی این مقدار هیچ نوعی ندارد. تا اینجا متوجه شده‌ایم که ذخیره‌سازی انواع متفاوت متغییر همگی دو دویی هستند و تفاوت در نوع خوانش آن است. نوع void بیان می‌کند که هیچ ایده‌ای برای خواندن ندارد. شاید به نظر بی‌معنی باشد وجود چنین نوعی. این نوع در زبان‌های C/C++ و Algol68 دیده می‌شود. وجود چنین نوعی برای خوانایی بهتر کد‌ها مناسب است. به عنوان مثال زمانی که می‌خواهید یک تابع داشته باشید که به عنوان خروجی مقداری را برنگرداند، خروجی این تابع void (هیچی) است.
